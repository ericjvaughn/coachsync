# AI SELF-CONTROL PROTOCOL

## ðŸš¨ CRITICAL RULES FOR AI (DO NOT IGNORE) ðŸš¨

### Rule 1: NO REFACTORING
- Phase 1 and 2 code is LOCKED and UNTOUCHABLE
- No "improvements" to existing code
- No "better ways" to do things
- No "efficiency improvements"
- If it works, DO NOT TOUCH IT

### Rule 2: STRICT PHASE ADHERENCE
- Build ONLY what is listed in Phase 3
- If a feature isn't listed, DO NOT BUILD IT
- If a task requires modifying Phases 1-2, STOP and ASK
- No "while we're here" additions

### Rule 3: SCOPE CONTROL
- Check "What NOT to Build" before EVERY task
- If you think "it would be nice to also...", STOP
- No adding "useful" features not in spec
- No "preparing" for future phases

### Rule 4: COMMUNICATION REQUIRED
- If stuck, ASK instead of modifying
- If you see a "better way", DISCUSS it first
- If you feel the urge to refactor, STOP and EXPLAIN why
- Never assume it's okay to modify existing code

### Rule 5: BUILD ON TOP, NOT INTO
- All features must work WITH existing code
- Use wrapper components and adapters
- Extend functionality through composition
- If you need to modify old code, STOP and DISCUSS

### Rule 6: LESS IS MORE
- Every line of code is a liability
- If it "might be useful later", don't write it
- Complexity dies by a thousand "helpful" additions
- No "just in case" code
- No "this might be handy" functions
- No "wrapper for future use"
- SIMPLE > CLEVER
- READABLE > ELEGANT
- MINIMAL > FLEXIBLE

### Rule 7: COMPLETE, DON'T FRAGMENT
- Finish EVERY task in the current scope
- No "I'll come back to this later"
- No partial implementations
- No "skeleton code" to fill in later
- If you start something, FINISH IT
- No moving on until current task is 100% done
- No splitting tasks across multiple sessions
- COMPLETION > PROGRESSION

Remember:
- Half-finished features are technical debt
- Partial implementations create confusion
- Coming back later means never
- Context switching kills productivity

EMBRACE:
âœ“ One task at a time
âœ“ Full implementation
âœ“ Complete documentation
âœ“ Thorough testing

AVOID:
âœ— "We can finish this later"
âœ— "Let's just get the basic structure"
âœ— "I'll add the details next time"
âœ— "This is good enough for now"

Remember:
- Each line of code you write is a line you'll maintain forever
- Each abstraction you add is complexity you'll explain forever
- Each "helpful utility" is a dependency you'll manage forever
- Each "flexible solution" is a decision you'll defend forever

Your job is to solve the problem, not build a framework.
Your goal is working software, not a showcase of patterns.
Your measure is business value, not code elegance.

EMBRACE:
âœ“ Small, focused functions
âœ“ Direct solutions
âœ“ Obvious code
âœ“ Clear names

AVOID:
âœ— "Flexible" abstractions
âœ— "Reusable" utilities
âœ— "Future-proof" patterns
âœ— "Generic" solutions

THE BEST CODE IS THE CODE YOU DIDN'T WRITE

## Documentation Search Guide

### Formation Management Docs
- Konva Groups: search "konva.js group management documentation"
- Templates: search "react component templates typescript"
- Drag & Drop: search "konva.js drag drop documentation"
- Event Handling: search "konva.js events documentation"

### Play Design Docs
- Route Drawing: search "konva.js path drawing documentation"
- Custom Shapes: search "konva.js custom shapes documentation"
- Animation: search "konva.js animation documentation"
- Interactions: search "konva.js pointer events documentation"

### UI/UX Docs
- Context Menu: search "react context menu typescript"
- Tooltips: search "react tooltip component documentation"
- Keyboard Events: search "react keyboard events documentation"
- Gesture Support: search "react gesture library documentation"

### Performance Docs
- React Optimization: search "react performance optimization documentation"
- Canvas Performance: search "konva.js performance tips documentation"
- Lazy Loading: search "react lazy loading documentation"
- Virtual Scrolling: search "react virtual scroll documentation"

### Search Tips
1. Always include "documentation" in search
2. Include "official" for primary sources
3. Add "typescript" for type definitions
4. Add "examples" for implementation patterns
5. Prioritize framework docs over blog posts

## BEFORE EVERY TASK, I MUST:
1. Read these rules again
2. Check the "What NOT to Build" list
3. Verify the task is explicitly listed in Phase 3
4. Confirm no modifications to Phases 1-2 are needed
5. If in doubt, STOP and ASK

# Phase 3: Core Features

## Formation Management
1. Implement formation creation interface
2. Add formation templates
3. Create formation preview system
4. Add formation editing tools
5. Implement formation search/filter

## Play Design Tools
1. Enhanced player placement
2. Advanced route drawing tools
3. Add play variations system
4. Implement play templates
5. Create play preview system

## Defense System
1. Add defensive formation tools
2. Implement coverage selection
3. Add blitz configuration
4. Create personnel packages
5. Add situation-based formations

## Enhanced UI/UX
1. Implement drag-and-drop
2. Add context menus
3. Create tooltips system
4. Enhance keyboard shortcuts
5. Add gesture controls

## Performance Optimization
1. Implement lazy loading
2. Add component memoization
3. Optimize canvas rendering
4. Add virtual scrolling
5. Implement caching system

## What NOT to Build Yet
- AI analysis features
- Game film integration
- Voice commands
- Mobile app features
- Advanced analytics
